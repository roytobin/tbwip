<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title> Puzzle Book for Easy Boggle Solitaire </title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="manifest"  xxhref="site.webmanifest">
<link rel="apple-touch-icon" sizes="180x180" xxhref="apple-touch-icon.png">

<!-- https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/MetaTags.html -->
<meta name="apple-mobile-web-app-title" content="Puzzle Book for Boggle Solitaire">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="format-detection" content="telephone=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="keywords"    content="boggle, solitaire, puzzle, JavaScript">
<meta name="description" content="Find words in a grid of letters">
<script>
window.boggleVersion = '0.1';
</script>
<style>
:root {
    --varOne: 10;
}
.a { transform: rotate(0deg); }
.b { transform: rotate(90deg); }
.c { transform: rotate(90deg); }
.d { transform: rotate(270deg); }
.e { transform: rotate(90deg); }
.f { transform: rotate(180deg); }
.g { transform: rotate(180deg); }
.h { transform: rotate(90deg); }
.i { transform: rotate(180deg); }
.j { transform: rotate(0deg); }
.k { transform: rotate(180deg); }
.l { transform: rotate(180deg); }
.m { transform: rotate(180deg); }
.n { transform: rotate(90deg); }
.o { transform: rotate(270deg); }
.p { transform: rotate(0deg); }
.line {
    font-weight: 100;
}
.solution {
    font-size: 80%;
}
.letsp {
    font-size: 75%;
    letter-spacing: 1.5vw;
}
.qu {
    font-size: 95%;
    letter-spacing: -2px;
}
.board {
    margin: auto;
    color: blue;
    font-weight: bold;
    width: 25%;  /* beware: render in print preview shifts to left */
    border: 1px solid black
    padding: 10px;
    xxfont-size: 2.5vw;
    font-size: 250%;
    letter-spacing: 2.6vw;
}
.grid {
    margin-left: auto;
    margin-right: auto;
    margin: auto;
    width: 50%;
    display: grid;
    xxgrid-template-columns: 3.8vw 3.8vw 3.8vw 3.8vw;
    grid-template-columns: 4.8vw 4.8vw 4.8vw 4.8vw;
}
.item {
    color: blue;
    font-weight: bold;
    xxborder: 1px solid green;
    font-family: monospace;
    font-size: 250%;
    text-align: center;
}
.answer {
    line-height: 180%;
    color: gray;
}
.pagebreak {
    page-break-after: always;
}
</style>
</head>

<body onload="bodyLoaded()">
<!--[if IE]>
  <h1> Internet Explorer is not supported </h1>
<![endif]-->
<noscript><h1> JavaScript is not enabled </h1></noscript>

<h4>Easy Boggle&trade; Solitaire &mdash; Puzzle 1 of 7</h4>
<h5>https://roytobin.github.io/ebs/ The five letter book code
for this book of puzzles: <span class="code"></span></h5>
<h4 id="hlh" style="display: none">How long hidden? </h4>
Find words in the grid using Boggle&trade; rules.
<br>
The computer found <span class=found1></span> non-arcane,
non-archaic and non-specialized US English words.<br>
How many can you find? <span id=percent1></span>
<br>
<br>
<pre id=grid1 class="board">
</pre>
<br>
<br>
<div class="answer">
&nbsp;&nbsp;1._____________________21._____________________41._____________________61._____________________<br>
&nbsp;&nbsp;2._____________________22._____________________42._____________________62._____________________<br>
&nbsp;&nbsp;3._____________________23._____________________43._____________________63._____________________<br>
&nbsp;&nbsp;4._____________________24._____________________44._____________________64._____________________<br>
&nbsp;&nbsp;5._____________________25._____________________45._____________________65._____________________<br>
&nbsp;&nbsp;6._____________________26._____________________46._____________________66._____________________<br>
&nbsp;&nbsp;7._____________________27._____________________47._____________________67._____________________<br>
&nbsp;&nbsp;8._____________________28._____________________48._____________________68._____________________<br>
&nbsp;&nbsp;9._____________________29._____________________49._____________________69._____________________<br>
10._____________________30._____________________50._____________________70._____________________<br>
11._____________________31._____________________51._____________________71._____________________<br>
12._____________________32._____________________52._____________________72._____________________<br>
13._____________________33._____________________53._____________________73._____________________<br>
14._____________________34._____________________54._____________________74._____________________<br>
15._____________________35._____________________55._____________________75._____________________<br>
16._____________________36._____________________56._____________________76._____________________<br>
17._____________________37._____________________57._____________________77._____________________<br>
18._____________________38._____________________58._____________________78._____________________<br>
19._____________________39._____________________59._____________________79._____________________<br>
20._____________________40._____________________60._____________________80._____________________<br>
</div>
<h5>Feedback:  https://github.com/roytobin/ebs/issues/ </h5>
<div class="pagebreak"></div>
<h4>Easy Boggle&trade; Solitaire &mdash; Puzzle 2 of 7</h4>
<h5>https://roytobin.github.io/ebs/ The five letter book code
for this book of puzzles: <span class="code"></span></h5>
<h4 id="hlh" style="display: none">How long hidden? </h4>
Find words in the grid using Boggle&trade; rules.
<br>
The computer found <span class=found2></span> non-arcane,
non-archaic and non-specialized US English words.<br>
How many can you find? <span id=percent2></span>
<br>
<br>
<pre id=grid2 class="board">
</pre>
<br>
<br>
<div class="answer">
&nbsp;&nbsp;1._____________________21._____________________41._____________________61._____________________<br>
&nbsp;&nbsp;2._____________________22._____________________42._____________________62._____________________<br>
&nbsp;&nbsp;3._____________________23._____________________43._____________________63._____________________<br>
&nbsp;&nbsp;4._____________________24._____________________44._____________________64._____________________<br>
&nbsp;&nbsp;5._____________________25._____________________45._____________________65._____________________<br>
&nbsp;&nbsp;6._____________________26._____________________46._____________________66._____________________<br>
&nbsp;&nbsp;7._____________________27._____________________47._____________________67._____________________<br>
&nbsp;&nbsp;8._____________________28._____________________48._____________________68._____________________<br>
&nbsp;&nbsp;9._____________________29._____________________49._____________________69._____________________<br>
10._____________________30._____________________50._____________________70._____________________<br>
11._____________________31._____________________51._____________________71._____________________<br>
12._____________________32._____________________52._____________________72._____________________<br>
13._____________________33._____________________53._____________________73._____________________<br>
14._____________________34._____________________54._____________________74._____________________<br>
15._____________________35._____________________55._____________________75._____________________<br>
16._____________________36._____________________56._____________________76._____________________<br>
17._____________________37._____________________57._____________________77._____________________<br>
18._____________________38._____________________58._____________________78._____________________<br>
19._____________________39._____________________59._____________________79._____________________<br>
20._____________________40._____________________60._____________________80._____________________<br>
</div>
<h5>Feedback:  https://github.com/roytobin/ebs/issues/ </h5>
<div class="pagebreak"></div>
<h4>Easy Boggle&trade; Solitaire &mdash; Puzzle 3 of 7</h4>
<h5>https://roytobin.github.io/ebs/ The five letter book code
for this book of puzzles: <span class="code"></span></h5>
<h4 id="hlh" style="display: none">How long hidden? </h4>
Find words in the grid using Boggle&trade; rules.
<br>
The computer found <span class=found3></span> non-arcane,
non-archaic and non-specialized US English words.<br>
How many can you find? <span id=percent3></span>
<br>
<br>
<pre id=grid3 class="board">
</pre>
<br>
<br>
<div class="answer">
&nbsp;&nbsp;1._____________________21._____________________41._____________________61._____________________<br>
&nbsp;&nbsp;2._____________________22._____________________42._____________________62._____________________<br>
&nbsp;&nbsp;3._____________________23._____________________43._____________________63._____________________<br>
&nbsp;&nbsp;4._____________________24._____________________44._____________________64._____________________<br>
&nbsp;&nbsp;5._____________________25._____________________45._____________________65._____________________<br>
&nbsp;&nbsp;6._____________________26._____________________46._____________________66._____________________<br>
&nbsp;&nbsp;7._____________________27._____________________47._____________________67._____________________<br>
&nbsp;&nbsp;8._____________________28._____________________48._____________________68._____________________<br>
&nbsp;&nbsp;9._____________________29._____________________49._____________________69._____________________<br>
10._____________________30._____________________50._____________________70._____________________<br>
11._____________________31._____________________51._____________________71._____________________<br>
12._____________________32._____________________52._____________________72._____________________<br>
13._____________________33._____________________53._____________________73._____________________<br>
14._____________________34._____________________54._____________________74._____________________<br>
15._____________________35._____________________55._____________________75._____________________<br>
16._____________________36._____________________56._____________________76._____________________<br>
17._____________________37._____________________57._____________________77._____________________<br>
18._____________________38._____________________58._____________________78._____________________<br>
19._____________________39._____________________59._____________________79._____________________<br>
20._____________________40._____________________60._____________________80._____________________<br>
</div>
<h5>Feedback:  https://github.com/roytobin/ebs/issues/ </h5>
<div class="pagebreak"></div>
<h4>Easy Boggle&trade; Solitaire &mdash; Puzzle 4 of 7</h4>
<h5>https://roytobin.github.io/ebs/ The five letter book code
for this book of puzzles: <span class="code"></span></h5>
<h4 id="hlh" style="display: none">How long hidden? </h4>
Find words in the grid using Boggle&trade; rules.
<br>
The computer found <span class=found4></span> non-arcane,
non-archaic and non-specialized US English words.<br>
How many can you find? <span id=percent4></span>
<br>
<br>
<pre id=grid4 class="board">
</pre>
<br>
<br>
<div class="answer">
&nbsp;&nbsp;1._____________________21._____________________41._____________________61._____________________<br>
&nbsp;&nbsp;2._____________________22._____________________42._____________________62._____________________<br>
&nbsp;&nbsp;3._____________________23._____________________43._____________________63._____________________<br>
&nbsp;&nbsp;4._____________________24._____________________44._____________________64._____________________<br>
&nbsp;&nbsp;5._____________________25._____________________45._____________________65._____________________<br>
&nbsp;&nbsp;6._____________________26._____________________46._____________________66._____________________<br>
&nbsp;&nbsp;7._____________________27._____________________47._____________________67._____________________<br>
&nbsp;&nbsp;8._____________________28._____________________48._____________________68._____________________<br>
&nbsp;&nbsp;9._____________________29._____________________49._____________________69._____________________<br>
10._____________________30._____________________50._____________________70._____________________<br>
11._____________________31._____________________51._____________________71._____________________<br>
12._____________________32._____________________52._____________________72._____________________<br>
13._____________________33._____________________53._____________________73._____________________<br>
14._____________________34._____________________54._____________________74._____________________<br>
15._____________________35._____________________55._____________________75._____________________<br>
16._____________________36._____________________56._____________________76._____________________<br>
17._____________________37._____________________57._____________________77._____________________<br>
18._____________________38._____________________58._____________________78._____________________<br>
19._____________________39._____________________59._____________________79._____________________<br>
20._____________________40._____________________60._____________________80._____________________<br>
</div>
<h5>Feedback:  https://github.com/roytobin/ebs/issues/ </h5>
<div class="pagebreak"></div>
<h4>Easy Boggle&trade; Solitaire &mdash; Puzzle 5 of 7</h4>
<h5>https://roytobin.github.io/ebs/ The five letter book code
for this book of puzzles: <span class="code"></span></h5>
<h4 id="hlh" style="display: none">How long hidden? </h4>
Find words in the grid using Boggle&trade; rules.
<br>
The computer found <span class=found5></span> non-arcane,
non-archaic and non-specialized US English words.<br>
How many can you find? <span id=percent5></span>
<br>
<br>
<pre id=grid5 class="board">
</pre>
<br>
<br>
<div class="answer">
&nbsp;&nbsp;1._____________________21._____________________41._____________________61._____________________<br>
&nbsp;&nbsp;2._____________________22._____________________42._____________________62._____________________<br>
&nbsp;&nbsp;3._____________________23._____________________43._____________________63._____________________<br>
&nbsp;&nbsp;4._____________________24._____________________44._____________________64._____________________<br>
&nbsp;&nbsp;5._____________________25._____________________45._____________________65._____________________<br>
&nbsp;&nbsp;6._____________________26._____________________46._____________________66._____________________<br>
&nbsp;&nbsp;7._____________________27._____________________47._____________________67._____________________<br>
&nbsp;&nbsp;8._____________________28._____________________48._____________________68._____________________<br>
&nbsp;&nbsp;9._____________________29._____________________49._____________________69._____________________<br>
10._____________________30._____________________50._____________________70._____________________<br>
11._____________________31._____________________51._____________________71._____________________<br>
12._____________________32._____________________52._____________________72._____________________<br>
13._____________________33._____________________53._____________________73._____________________<br>
14._____________________34._____________________54._____________________74._____________________<br>
15._____________________35._____________________55._____________________75._____________________<br>
16._____________________36._____________________56._____________________76._____________________<br>
17._____________________37._____________________57._____________________77._____________________<br>
18._____________________38._____________________58._____________________78._____________________<br>
19._____________________39._____________________59._____________________79._____________________<br>
20._____________________40._____________________60._____________________80._____________________<br>
</div>
<h5>Feedback:  https://github.com/roytobin/ebs/issues/ </h5>
<div class="pagebreak"></div>
<h4>Easy Boggle&trade; Solitaire &mdash; Puzzle 6 of 7</h4>
<h5>https://roytobin.github.io/ebs/ The five letter book code
for this book of puzzles: <span class="code"></span></h5>
<h4 id="hlh" style="display: none">How long hidden? </h4>
Find words in the grid using Boggle&trade; rules.
<br>
The computer found <span class=found6></span> non-arcane,
non-archaic and non-specialized US English words.<br>
How many can you find? <span id=percent6></span>
<br>
<br>
<pre id=grid6 class="board">
</pre>
<br>
<br>
<div class="answer">
&nbsp;&nbsp;1._____________________21._____________________41._____________________61._____________________<br>
&nbsp;&nbsp;2._____________________22._____________________42._____________________62._____________________<br>
&nbsp;&nbsp;3._____________________23._____________________43._____________________63._____________________<br>
&nbsp;&nbsp;4._____________________24._____________________44._____________________64._____________________<br>
&nbsp;&nbsp;5._____________________25._____________________45._____________________65._____________________<br>
&nbsp;&nbsp;6._____________________26._____________________46._____________________66._____________________<br>
&nbsp;&nbsp;7._____________________27._____________________47._____________________67._____________________<br>
&nbsp;&nbsp;8._____________________28._____________________48._____________________68._____________________<br>
&nbsp;&nbsp;9._____________________29._____________________49._____________________69._____________________<br>
10._____________________30._____________________50._____________________70._____________________<br>
11._____________________31._____________________51._____________________71._____________________<br>
12._____________________32._____________________52._____________________72._____________________<br>
13._____________________33._____________________53._____________________73._____________________<br>
14._____________________34._____________________54._____________________74._____________________<br>
15._____________________35._____________________55._____________________75._____________________<br>
16._____________________36._____________________56._____________________76._____________________<br>
17._____________________37._____________________57._____________________77._____________________<br>
18._____________________38._____________________58._____________________78._____________________<br>
19._____________________39._____________________59._____________________79._____________________<br>
20._____________________40._____________________60._____________________80._____________________<br>
</div>
<h5>Feedback:  https://github.com/roytobin/ebs/issues/ </h5>
<div class="pagebreak"></div>
<h4>Easy Boggle&trade; Solitaire &mdash; Puzzle 7 of 7</h4>
<h5>https://roytobin.github.io/ebs/ The five letter book code
for this book of puzzles: <span class="code"></span></h5>
<h4 id="hlh" style="display: none">How long hidden? </h4>
Find words in the grid using Boggle&trade; rules.
<br>
The computer found <span class=found7></span> non-arcane,
non-archaic and non-specialized US English words.<br>
How many can you find? <span id=percent7></span>
<br>
<br>
<pre id=grid7 class="board">
</pre>
<br>
<br>
<div class="answer">
&nbsp;&nbsp;1._____________________21._____________________41._____________________61._____________________<br>
&nbsp;&nbsp;2._____________________22._____________________42._____________________62._____________________<br>
&nbsp;&nbsp;3._____________________23._____________________43._____________________63._____________________<br>
&nbsp;&nbsp;4._____________________24._____________________44._____________________64._____________________<br>
&nbsp;&nbsp;5._____________________25._____________________45._____________________65._____________________<br>
&nbsp;&nbsp;6._____________________26._____________________46._____________________66._____________________<br>
&nbsp;&nbsp;7._____________________27._____________________47._____________________67._____________________<br>
&nbsp;&nbsp;8._____________________28._____________________48._____________________68._____________________<br>
&nbsp;&nbsp;9._____________________29._____________________49._____________________69._____________________<br>
10._____________________30._____________________50._____________________70._____________________<br>
11._____________________31._____________________51._____________________71._____________________<br>
12._____________________32._____________________52._____________________72._____________________<br>
13._____________________33._____________________53._____________________73._____________________<br>
14._____________________34._____________________54._____________________74._____________________<br>
15._____________________35._____________________55._____________________75._____________________<br>
16._____________________36._____________________56._____________________76._____________________<br>
17._____________________37._____________________57._____________________77._____________________<br>
18._____________________38._____________________58._____________________78._____________________<br>
19._____________________39._____________________59._____________________79._____________________<br>
20._____________________40._____________________60._____________________80._____________________<br>
</div>
<h5>Feedback:  https://github.com/roytobin/ebs/issues/ </h5>
<div class="pagebreak"></div>

<h4> Solution page for Easy Boggle Solitaire </h4>
<h5>https://roytobin.github.io/ebs/ The five letter book code
for this book of puzzles: <span class="code"></span></h5>

<h4>Puzzle 1</h4>
<p class="solution"><span class=found1></span> words found &mdash; <span id=solution1></span>
<br>
<h4>Puzzle 2</h4>
<p class="solution"><span class=found2></span> words found &mdash; <span id=solution2></span>
<br>
<h4>Puzzle 3</h4>
<p class="solution"><span class=found3></span> words found &mdash; <span id=solution3></span>
<br>
<h4>Puzzle 4</h4>
<p class="solution"><span class=found4></span> words found &mdash; <span id=solution4></span>
<br>
<h4>Puzzle 5</h4>
<p class="solution"><span class=found5></span> words found &mdash; <span id=solution5></span>
<br>
<h4>Puzzle 6</h4>
<p class="solution"><span class=found6></span> words found &mdash; <span id=solution6></span>
<br>
<h4>Puzzle 7</h4>
<p class="solution"><span class=found7></span> words found &mdash; <span id=solution7></span>
<br>

<script defer src="enctrie.js"></script>
<script>
"use strict"

const NumPuzzles = 7;

// BEGIN
// A generator function that produces
// a [0,1) prng function using 'code' as seed
//
function mk_prng(code) {
    // From https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
    // which references http://pracrand.sourceforge.net/
    //
    // [tobin] beware!  experiments show that after seeding the first few values
    // returned are all very close to zero, which is not randomness.  Perhaps
    // the function needs to be called several times after seeding to start
    // to get pseudo-random sequence.
    // [update 7/16/2021: now believe above trouble is due to poor seeding.
    //  Updated to use xmur3() to harvest reasonable seed numbers]
    //
    function sfc32(a, b, c, d) {
	return function() {
	  a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
	  var t = (a + b) | 0;
	  a = b ^ b >>> 9;
	  b = c + (c << 3) | 0;
	  c = (c << 21 | c >>> 11);
	  d = d + 1 | 0;
	  t = t + d | 0;
	  c = c + t | 0;
	  return (t >>> 0) / 4294967296;
	}
    }
    function xmur3(str) {
	for(var i = 0, h = 1779033703 ^ str.length; i < str.length; i++)
	    h = Math.imul(h ^ str.charCodeAt(i), 3432918353),
	    h = h << 13 | h >>> 19;
	return function() {
	    h = Math.imul(h ^ h >>> 16, 2246822507),
	    h = Math.imul(h ^ h >>> 13, 3266489909);
	    return (h ^= h >>> 16) >>> 0;
	}
    }
    // Here, use a hash function to generate better quality seeds.
    // Reference https://github.com/bryc/code/blob/master/jshash/\
    //	PRNGs.md#addendum-a-seed-generating-functions
    //
    var sgf = xmur3(code);   // sgf() == seedGeneratingFunction
    return sfc32(sgf(), sgf(), sgf(), sgf());
}
// END
// BEGIN
function boggle(myrand) { // argument 'myrand' must be a PRNG function in interval [0,1)

    let die = [];
    die[ 0] = "IHNUMQ";
    die[ 1] = "EOTSSI";
    die[ 2] = "HNLNZR";
    die[ 3] = "AWTOOT";
    die[ 4] = "EEHNWG";
    die[ 5] = "EEGNAA";
    die[ 6] = "ERLIXD";
    die[ 7] = "EYTLRT";
    die[ 8] = "CMUOIT";
    die[ 9] = "AHSPOC";
    die[10] = "DRYVLE";
    die[11] = "ERWTVH";
    die[12] = "ABBOOJ";
    die[13] = "ASPFKF";
    die[14] = "EEUSIN";
    die[15] = "DTYTIS";

    function fisheryates(a) {  // shuffle (permute) the passed array in place
        for (let idx = a.length; --idx;) {
	    let j = Math.floor((idx+1)*myrand());
	    let t = a[j];
	    a[j] = a[idx];
	    a[idx] = t;
	}
	return a;
    }
    return function () { 
        let dice = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
        let perm = fisheryates(dice);  // permute the order


        let game = '';
	for(let idx = 0; idx < 16; ++idx) {
	    game = game + die[ perm[idx] ][ Math.floor(6*myrand()) ];
	}
	return game;
    }
}
// END
// BEGIN
let TR_STANDALONE = 0;
let harvest = 0;
function mk_solver() {
/*
 A Succinct Trie for Javascript   https://www.hanovsolutions.com/trie/

 By Steve Hanov
 Released to the public domain.

 This file contains functions for creating a succinctly encoded trie structure
 from a list of words. The trie is encoded to a succinct bit string using the
 method of Jacobson (1989). The bitstring is then encoded using BASE-64. 
 
 The resulting trie does not have to be decoded to be used. This file also
 contains functions for looking up a word in the BASE-64 encoded data, in
 O(mlogn) time, where m is the number of letters in the target word, and n is
 the number of nodes in the trie.

 Objects for encoding:
 TrieNode
 Trie
 BitWriter
 RankDirectory.Create (just this method of the class)

 Objects for decoding:
 BitString
 FrozenNode
 FrozenTrie
 RankDirectory

 QUICK USAGE:

 Suppose we let data be some output of the demo encoder:

 var data = {
    "nodeCount": 37,
    "directory": "BMIg",
    "trie": "v2qqqqqqqpIUn4A5JZyBZ4ggCKh55ZZgBA5ZZd5vIEl1wx8g8A"
 };

 var frozenTrie = new FrozenTrie( Data.trie, Data.directory, Data.nodeCount);

 alert( frozenTrie.lookup( "hello" ) ); // outputs true
 alert( frozenTrie.lookup( "kwijibo" ) ); // outputs false

*/   

// Configure the bit writing and reading functions to work natively in BASE-64 
// encoding. That way, we don't have to convert back and forth to bytes.

let Game;
Game = "qwerasdfzxcvtegb";
Game = "eyleseeaovtiitqg";
Game = "twstnksijeeltswz";
let debugString = "";
let callsToSelect = 0;	// profiling
let hist = [];
let Memoization = [];
var BASE64 =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

/**
    The width of each unit of the encoding, in bits. Here we use 6, for base-64
    encoding.  If this W changes, need to also change ORD(), CHR() and BitString.MaskTop
 */
const W = 7;  

function setGame(g) { Game = g }

/**
    Returns the character unit that represents the given value.  If this were
    binary data, we would simply return id.
 */
function CHR(id) 
{
    return String.fromCharCode(id);	// W=7
    return BASE64[id];			// W=6
}

/** 
    Returns the decimal value of the given character unit.
 */
var BASE64_CACHE = {"A" : 0, "B" : 1, "C" : 2, "D" : 3, "E" : 4, "F" : 5, "G" :
    6, "H" : 7, "I" : 8, "J" : 9, "K" : 10, "L" : 11, "M" : 12, "N" : 13, "O" :
    14, "P" : 15, "Q" : 16, "R" : 17, "S" : 18, "T" : 19, "U" : 20, "V" :
    21, "W" : 22, "X" : 23, "Y" : 24, "Z" : 25, "a" : 26, "b" : 27, "c" :
    28, "d" : 29, "e" : 30, "f" : 31, "g" : 32, "h" : 33, "i" : 34, "j" :
    35, "k" : 36, "l" : 37, "m" : 38, "n" : 39, "o" : 40, "p" : 41, "q" :
    42, "r" : 43, "s" : 44, "t" : 45, "u" : 46, "v" : 47, "w" : 48, "x" :
    49, "y" : 50, "z" : 51, "0" : 52, "1" : 53, "2" : 54, "3" : 55, "4" :
    56, "5" : 57, "6" : 58, "7" : 59, "8" : 60, "9" : 61, "-" : 62, "_" :
    63};

function ORD(ch) 
{
    // Used to be: (see below)
    return ch.charCodeAt(0);  // use 7-bit ASCII codes directly (one-for-one)

    // Used to be: return BASE64.indexOf(ch);
    return BASE64_CACHE[ch];  // W=6
}

/**
    Fixed values for the L1 and L2 table sizes in the Rank Directory
*/
let L1, L2;
L2 = 16;
L2 = 32;
L2 = 64;
L1 = L2*L2;

/**
    The BitWriter will create a stream of bytes, letting you write a certain
    number of bits at a time. This is part of the encoder, so it is not
    optimized for memory or speed.
*/
function BitWriter()
{
    this.init();
}

BitWriter.prototype = 
{
    init: function() {
        this.bits = [];
    },

    /**
        Write some data to the bit string. The number of bits must be 32 or
        fewer.
    */
    write: function( data, numBits ) {
        for( var i = numBits - 1; i >= 0; i-- ) {
            if ( data & ( 1 << i ) ) {
                this.bits.push(1);
            } else {
                this.bits.push(0);
            }
        }
    },

    put7Data: function(id) {   // Bit Writer->put7Data to console the 7-bit ASCII codes
        let b = 0;
	let i = 0;

	console.log(`@ ${id}`);
        for (let j = 0; j < this.bits.length; ++j) {
	    b = (b << 1) | this.bits[j];
	    if ( ++i === W ) {
	        console.log(b);
		i = b = 0;
	    }
	}
	if (i) {
	    console.log(b << (W-i));  // pad with 0s if needed
	}
	console.log("@ trailer");
    },
    /**
        Return an encoded string representation.
        [old] Return the base64 representation of the this.bits array of 1s & 0s.
    */
    getData: function() {   // Bit Writer->getData
        var chars = [];
        var b = 0;
        var i = 0;

        for ( let j = 0; j < this.bits.length; j++ ) {
            b = ( b << 1 ) | this.bits[j];
            i += 1;
            if ( i === W ) {
                chars.push( CHR(b) );
                i = b = 0;
            }
        }
        if ( i ) {
            chars.push( CHR(b << ( W - i )) );  // pad with 0s if needed
        }
        return chars.join("");
    },

    /**
        Returns the bits as a human readable binary string for debug
     */
    getDebugString: function(group) {
        var chars = [];
        var i = 0;
        
        for( var j = 0; j < this.bits.length; j++ ) {
            chars.push( "" + this.bits[j] );
            i++;
            if ( i === group ) {
                chars.push( ' ' );
                i = 0;
            }
        }
        return chars.join("");
    },
};

/**
    Given a string of data (eg, in BASE-64), the BitString class supports
    reading or counting a number of bits from an arbitrary position in the
    string.
*/
function BitString( str )
{
    this.init( str );
}

BitString.MaskTop = [ 
    /* W=6            0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00    /* W dependency */
    /* W=7 */   0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00    /* W dependency */
];

BitString.BitsInByte = [ 
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2,
    3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3,
    3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3,
    4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4,
    3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5,
    6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4,
    4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5,
    6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5,
    3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3,
    4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6,
    6, 7, 6, 7, 7, 8 
];

BitString.prototype = {
    init: function( str ) {
        this.bytes = str;
        this.length = this.bytes.length * W;
    },

    /**
      Returns the internal string of bytes
    */
    getData: function() {
        return this.bytes;
    },

    /**
        Returns a decimal number, consisting of a certain number, n, of bits
        starting at a certain position, p.
     */
    get: function( p, n ) {

        // case 1: bits lie within the given byte
        if ( ( p % W ) + n <= W ) {
            return ( ORD( this.bytes[ p / W | 0 ] ) & BitString.MaskTop[ p % W ] ) >> 
                ( W - p % W - n );

        // case 2: bits lie incompletely in the given byte
        } else {
            var result = ( ORD( this.bytes[ p / W | 0 ] ) & 
                BitString.MaskTop[ p % W ] );

            var l = W - p % W;
            p += l;
            n -= l;

            while ( n >= W ) {
                result = (result << W) | ORD( this.bytes[ p / W | 0 ] );
                p += W;
                n -= W;
            }

            if ( n > 0 ) {
                result = (result << n) | ( ORD( this.bytes[ p / W | 0 ] ) >> 
                    ( W - n ) );
            }
            return result;
        }
    },

    /**
        Counts the number of bits set to 1 starting at position p and
        ending at position p + n
     */
    count: function( p, n ) {

        var count = 0;
        while( n >= 8 ) {
            count += BitString.BitsInByte[ this.get( p, 8 ) ];
            p += 8;
            n -= 8;
        }
        return count + BitString.BitsInByte[ this.get( p, n ) ];
    },

    /**
        Returns the number of bits set to 1 up to and including position x.
        This is the slow implementation used for testing.
    */
    rankSlowDebug: function( x ) {
        var rank = 0;
        for( var i = 0; i <= x; i++ ) {
            if ( this.get(i, 1) ) {
                rank++;
            }
        }
        return rank;
    }
};// BitString.prototype

/**
    The rank directory allows you to build an index to quickly compute the
    rank() and select() functions.  The index can itself be encoded as a binary
    string.
 */
function RankDirectory( directoryData, bitData, numBits, l1Size, l2Size )
{
    this.init(directoryData, bitData, numBits, l1Size, l2Size);
}

/**
    Used to build a rank directory from the given input string.

    @param data A javascript string containing the data, as readable using the
    BitString object.

    @param numBits The number of bits to index.
    
    @param l1Size The number of bits that each entry in the Level 1 table
    summarizes.  This should be a multiple of l2Size.

    @param l2Size The number of bits that each entry in the Level 2 table
    summarizes.
 */
RankDirectory.Create = function( data, numBits, l1Size, l2Size ) {
    var bits = new BitString( data );
    var p = 0;
    var i = 0;
    var count1 = 0, count2 = 0;
    var l1bits = Math.ceil( Math.log( numBits ) / Math.log(2) );
    var l2bits = Math.ceil( Math.log( l1Size ) / Math.log(2) );

    //console.log("l1/l2bits", l1bits,l2bits);

    var directory = new BitWriter();

    while( p + l2Size <= numBits ) {
        count2 += bits.count( p, l2Size );
        i += l2Size;
        p += l2Size;
        if ( i === l1Size ) {
            count1 += count2;
            directory.write( count1, l1bits );
            count2 = 0;
            i = 0;
        } else {
            directory.write( count2, l2bits );
        }
    }
    if (harvest) directory.put7Data("encDir");
    return new RankDirectory( directory.getData(), data, numBits, l1Size, l2Size );
};


RankDirectory.prototype = {

    init: function( directoryData, bitData, numBits, l1Size, l2Size ) {
        this.directory = new BitString( directoryData );
        this.data = new BitString( bitData );
        this.l1Size = l1Size;
        this.l2Size = l2Size;
        this.l1Bits = Math.ceil( Math.log( numBits ) / Math.log( 2 ) );
        this.l2Bits = Math.ceil( Math.log( l1Size ) / Math.log( 2 ) );
        this.sectionBits = (l1Size / l2Size - 1) * this.l2Bits + this.l1Bits;
        this.numBits = numBits;
    },

    /**
        Returns the string representation of the directory.
     */
    getData: function() {
        return this.directory.getData();
    },

    /**
      Returns the number of 1 or 0 bits (depending on the "which" parameter)
      up to and including position x.
      */
    rank: function( which, x ) {

        if ( which === 0 ) {
            return x - this.rank( 1, x ) + 1;
        }

        var rank = 0;              
        var o = x;
        var sectionPos = 0;

        if ( o >= this.l1Size ) {
            sectionPos = ( o / this.l1Size | 0 ) * this.sectionBits;
            rank = this.directory.get( sectionPos - this.l1Bits, this.l1Bits );
            o = o % this.l1Size;
        }

        if ( o >= this.l2Size ) {
            sectionPos += ( o / this.l2Size | 0 ) * this.l2Bits;
            rank += this.directory.get( sectionPos - this.l2Bits, this.l2Bits );
        }
	return rank + this.data.count( x - x % this.l2Size, x % this.l2Size + 1 );
    },

    /**
      Returns the position of the y'th 0 or 1 bit, depending on the "which"
      parameter.
      */
    select: function( which, y ) {
        var high = this.numBits;
        var low = -1;
        var val = -1;

	++callsToSelect;  // profiling: log the # of times this binary search runs

        while ( high - low > 1 ) {
            var probe = (high + low) / 2 | 0;
            var r = this.rank( which, probe );

            if ( r === y ) {
                // We have to continue searching after we have found it,
                // because we want the _first_ occurrence.
                val = probe;
                high = probe;
            } else if ( r < y ) {
                low = probe;
            } else {
                high = probe;
            }
        }
        return val;
    }
};

/**
  A Trie node, for use in building the encoding trie. This is not needed for
  the decoder.
  */
function TrieNode( letter )
{
    this.letter = letter;
    this.final = false;
    this.children = [];
}

function Trie()
{
    this.init();
}

Trie.prototype = {
    init: function() {
        this.previousWord = "";
        this.root = new TrieNode(' ');
        this.cache = [ this.root ];
        this.nodeCount = 1;
    },

    /**
      Returns the number of nodes in the trie
     */
    getNodeCount: function() {
        return this.nodeCount;
    },

    /**
      Inserts a word into the trie.  This function is fastest if the words are
      inserted in alphabetical order.
     */
    insert: function( word ) {      

        var commonPrefix = 0;
        for(let i = 0; i < Math.min(word.length, this.previousWord.length); i++ ) {
            if ( word[i] !== this.previousWord[i] ) { break; }
            commonPrefix += 1;
        }

        this.cache.length = commonPrefix + 1;
        var node = this.cache[ this.cache.length - 1 ];

        for( let i = commonPrefix; i < word.length; i++ ) {
            var next = new TrieNode( word[i] );
            this.nodeCount++;
            node.children.push( next );
            this.cache.push( next );
            node = next;
        }

        node.final = true;
        this.previousWord = word;
    },

    /**
      Invoke the supplied function for every node in trie,
      traversing the trie in level (breadth-first) order.
      */
    traverseTree: function( fn )   // was apply(), which is a method claimed by JavaScript
    {
        var level = [ this.root ];
        while( level.length > 0 ) {
            var node = level.shift();
            for( var i = 0; i < node.children.length; i++ ) {
                level.push( node.children[i] );
            }
            fn( node );
        }
    },

    /**
      Encode the trie and all of its nodes.  Returns a string representing the
      encoded data.
      */
    encode: function()
    {
        // Write the unary encoding of the tree in level order.
        var bits = new BitWriter();
        bits.write( 0x02, 2 );  // This is the "super" node
        this.traverseTree( function( node ) {
            for( var i = 0; i < node.children.length; i++ ) {
                bits.write( 1, 1 );
            }
            bits.write( 0, 1 );
        });

	// Write the data for each node, using 6 bits per node.
	// In bit[5], store the "final" flag.  The remaining five
	// lower bits encode a lowercase letter of the latin alphabet.
	//
        var a = ("a").charCodeAt(0);
        this.traverseTree( function( node ) {
            var value = node.letter.charCodeAt(0) - a;

	    // The root node has an associated "letter" of ascii space,
	    // and ' ' - 'a' = -65.  That is why the root node appears
	    // in the encoded bitsequence as six 1s (0x3f)
	    //

            if ( node.final ) {
                value |= 0x20;
            }

            bits.write( value, 6 );
        });

        debugString = bits.getDebugString(7);  // arg[0]: number of bits printed between spaces
	if (harvest) bits.put7Data("encTrie");
        return bits.getData();
    }// encode()
};

/**
  This class is used for traversing the succinctly encoded trie.
  */
function FrozenNode( trie, index, letter, final, firstChild, childCount )
{
    this.trie = trie;
    this.index = index;
    this.letter = letter;
    this.final = final;
    this.firstChild = firstChild;
    this.childCount = childCount;
}

FrozenNode.prototype = {
    /**
      Returns the number of children.
      */
    getChildCount: function()
    {
        return this.childCount;
    },

    /**
      Returns the FrozenNode for the given child.

      @param index The 0-based index of the child of this node. For example, if
      the node has 5 children, and you wanted the 0th one, pass in 0.
    */
    getChild: function(index) 
    {
        return this.trie.getNodeByIndex( this.firstChild + index );
    }
};

/**
    The FrozenTrie is used for looking up words in the encoded trie.

    @param data A string representing the encoded trie.

    @param directoryData A string representing the RankDirectory. The global L1
    and L2 constants are used to determine the L1Size and L2size.

    @param nodeCount The number of nodes in the trie.
  */
function FrozenTrie( data, directoryData, nodeCount )
{
    this.init( data, directoryData, nodeCount );
}

FrozenTrie.prototype = {
    init: function( data, directoryData, nodeCount )
    {
        this.data = new BitString( data );
        this.directory = new RankDirectory( directoryData, data, 
                nodeCount * 2 + 1, L1, L2 );

        // The position of the first bit of the data in 0th node. In non-root
        // nodes, this would contain 6-bit letters.
        this.letterStart = nodeCount * 2 + 1;
	this.All_found = Object.create(null);
    },

    /**
       Retrieve the FrozenNode of the trie, given its index in level-order.
       This is a private function that you don't have to use.
      */
    getNodeByIndex: function( index )
    {
        if (Memoization[index])	// if already constructed a FrozenNode for this index
	    return Memoization[index];


        // retrieve the 6-bit letter.
        var final = this.data.get( this.letterStart + index * 6, 1 ) === 1;
        var letter = String.fromCharCode(
                this.data.get( this.letterStart + index * 6 + 1, 5 ) + 
                'a'.charCodeAt(0));
        var firstChild = this.directory.select( 0, index+1 ) - index;

        // Since the nodes are in level order, this node's children must go up
        // until the next node's children start.
	//
        var childOfNextNode = this.directory.select( 0, index + 2 ) - index - 1;

	return Memoization[index] = new FrozenNode( this, index, letter, final, firstChild,
                childOfNextNode - firstChild );
    },

    /**
      Retrieve the root node.  You can use this node to obtain all of the other
      nodes in the trie.
      */
    getRoot: function()
    {
        return this.getNodeByIndex( 0 );
    },

    movesPossible: function(position) {
	switch(position) {
	case 0 :  return [1, 5, 4];
        case 1 :  return [0, 2, 6, 5, 4];
        case 2 :  return [1, 3, 7, 6, 5];
        case 3 :  return [2, 6, 7];
        case 4 :  return [0, 1, 5, 9, 8];
        case 5 :  return [1, 2, 6, 10, 9, 8, 4, 0];
        case 6 :  return [2, 3, 7, 11, 10, 9, 5, 1];
        case 7 :  return [3, 11, 10, 6, 2];
        case 8 :  return [4, 5, 9, 13, 12];
        case 9 :  return [5, 6, 10, 14, 13, 12, 8, 4];
        case 10 : return [6, 7, 11, 15, 14, 13, 9, 5];
        case 11 : return [7, 15, 14, 10, 6];
        case 12 : return [8, 9, 13];
        case 13 : return [9, 10, 14, 12, 8];
        case 14 : return [10, 11, 15, 13, 9];
        case 15 : return [11, 14, 10];
	default: console.log("Error: movesPossible()");
	}
    },

    getSearchResults: function() {
        return Object.keys(this.All_found).sort();
    },
    detect: function(word) {
        this.All_found[word] = 1;
    },

    // @param base -- This is a FrozenNode
    // @param pos -- a small integer, 0..15, representing a position on a 4x4 puzzle grid
    // @param word -- a string, rep'ing the growing letter sequence that may be a found word
    // @param verboten -- an integer bit vector of grid position verboten to backtrack to
    wordfind: function(base, pos, word, verboten) {
        let letter = Game[pos];
	let child;

	//console.log("wordfind 3", letter);

	child = this.getChildByLetter(base, letter);
	if (!child)
	    return;

	// A Q on the grid advances the search up to the U also.
	//
	if ('q' === letter) {
	    letter += 'u';
	    child = this.getChildByLetter(child, 'u');
	}
	if (!child)
	    return;

	if (child.final) {
	    this.detect(word+letter);
	}
	verboten = verboten | (1<<pos);
	for (let next_move of this.movesPossible(pos)) {
	    if (verboten & (1<<next_move))
	        continue;
	    this.wordfind(child, next_move, word+letter, verboten);  // recur
	}
    },

    // @param parent is a FrozenNode
    // @param letter is a string (expect it to be a single character)
    getChildByLetter: function (parent, letter) {
        let child;

	//console.log("getChildByLetter 3", letter, parent.getChildCount());
        for (var idx=0; idx < parent.getChildCount(); ++idx) {
	    child = parent.getChild(idx);
	    //console.log("getChildByLetter 5", child.letter);
	    if (child.letter === letter) {
	        return child;
	    }
	    else if (child.letter > letter) {
	        return null;
	    }
	}
	return null;
    },

    /**
      Look-up a word in the trie.  Returns true if and only if the word exists
      in the trie.
      */
    lookup: function( word ) 
    {

        var node = this.getRoot();
        for ( var i = 0; i < word.length; i++ ) {
            var child;
            for ( var j = 0; j < node.getChildCount(); j++ ) {
                child = node.getChild( j );


		// If the child node's letter matches what we are seeking,
		// we are done.  Also, since the trie is in sorted order,
		// if this linear search moves beyond the letter we seek,
		// then we know it doesn't exist.   It is therefore a waste of time
		// to examine the remaining children nodes.
		//
                if ( child.letter === word[i] ) {
                    break;
                }
		else if (child.letter > word[i]) {  // short-cut
		    return false;
		}
            }

            if ( j === node.getChildCount() ) {
                return false;
            }
            node = child;
        }
        return node.final;
    }
};// FrozenTrie prototype

function getWords() {
        let wordArr;
        //return ["hat", "peace", "hats"];
        //return ["hats"];
	wordArr = ["hat", "hats", "it", "is", "a", "sax", "saxc", "get"];
	wordArr = ["hat", "it", "is", "a", ];
	wordArr = readFile("../boggle/everyday").split('\n');
	//wordArr.length = 500;
	return wordArr;
}

/**
  Encode the trie in the input text box.
  */
function go()
{
    // create a trie
    var trie = new Trie();

    // split the words of the input up.  Sort them for faster trie insertion.
    var words = getWords();

    // [tobin] I suspect this sorting is not just required for
    // "faster trie insertion," but is fundamentally required to make it work.
    // Update: I'm correct: word list must be sorted.
    //
    words.sort();

    // For every word in the array, convert to lowercase and 
    // insert if result is exclusively letters and also non-zero length.
    //
    for ( var i = 0; i < words.length; i++ ) {
        // To save space, our encoding handles only the letters a-z. Ignore
        // words that contain other characters.
        var word = words[i].toLowerCase();
        if ( word.match( /^[a-z]+$/ ) ) {
            trie.insert( word );
        }
    }

    // Encode the trie and represent as base64.
    var trieData = trie.encode();

    // Encode the rank directory
    var directory = RankDirectory.Create( trieData, trie.getNodeCount() * 2 +
            1, L1, L2 );
    var output;
    
    output = '{\n    "nodeCount": ' + trie.getNodeCount() + ",\n";
    
    output += '    "directory": "' + directory.getData() + '",\n';
    
    output += '    "trie": "' + trieData + '"\n';
    output += '}\n';

    if (harvest) console.log(`@ nodeCount ${trie.getNodeCount()}`);

    return output;
}// go()


/**
  Decode the data in the output textarea, and use it to check if a word exists
  in the dictionary.
  */
// @param so  Is a string of a object literal {trie, directory, nodeCount} representing
//            the base64 encoded trie, its directory, and number of non-super nodes.
// @param w   Is a non-empty string of the all-lowercase word to check existence.
function searchTrie(so, w)   
{
    var status = "";
    try 
    {
        var json = (so) ? eval(`(${so})`) : eval( '(' + document.getElementById("output").value + ")" );

        var ftrie = new FrozenTrie( json.trie, json.directory, json.nodeCount);
        var word = w || document.getElementById("lookup").value;


        if ( ftrie.lookup( word ) ) {
            status = '"' + word + '" is in the dictionary.';
        } else {
            status = '"' + word + '" IS NOT in the dictionary.';
        }
    } catch ( e ) {
        status = "Error. Have you encoded the dictionary yet?";
    }

    if (w) return status;
    document.getElementById("status").innerHTML = status;
}
function searchGame(so) {
    console.log("searchGame 0", encTrie.length, nodeCount);
    //try {
	//let json = JSON.parse(so);  // Used to be: eval(`(${so})`);


        var ftrie = new FrozenTrie( encTrie, encDir, nodeCount);
        //var ftrie = new FrozenTrie( json.trie, json.directory, json.nodeCount);

	console.log("searchGame 7 dir len");
	if (0) {
	    let pos = 0;
	    ftrie.wordfind(ftrie.getRoot(), pos, "", 0);
	}
	else {
	for (let pos = 0; pos < 16; ++pos) {
	    ftrie.wordfind(ftrie.getRoot(), pos, "", 0);
	}
	}
	console.log("searchGame 9");  
	return ftrie.getSearchResults();
    //} catch (e) { return ["Error. searchGame() Have you encoded the dictionary yet?"]; }
}
return {setGame: setGame,  go: go,   searchGame: searchGame};
}
// END

function getUrlVars() {
    var vars = {};
    var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) {
        vars[key] = value;
    });
    return vars;
}
function checkCode() {
    let code = getUrlVars()["code"];
    if ( undefined === code ) {
	window.location.href = "index.html";
    }
    return code;
}

function populateCode(code) {
    for (let elem of document.querySelectorAll(".code")) {
        elem.innerHTML = code;
    }
}
function populateGrid(idx, puz) {
    let quReplacement = '<span class="qu">Q</span><span class="letsp">u</span>';
    let res = puz.split(/(\w{4})/);
    let elem = document.getElementById(`grid${idx}`);

    res[1] = res[1].replace('Q', quReplacement);
    res[3] = res[3].replace('Q', quReplacement);
    res[5] = res[5].replace('Q', quReplacement);
    res[7] = res[7].replace('Q', quReplacement);
    elem.innerHTML = [res[1], res[3], res[5], res[7]].join("\n");
}
function populateDOM(idx, sol) {
    let elem, found;

    found = sol.length;
    for (elem of document.querySelectorAll(`.found${idx}`)) {
	elem.innerHTML = found.toString();
    }

    let p65 = Math.round(0.65 * found);
    let p70 = Math.round(0.70 * found);
    let p75 = Math.round(0.75 * found);
    let p80 = Math.round(0.80 * found);
    let p85 = Math.round(0.85 * found);
    elem = document.getElementById(`percent${idx}`);
    elem.innerHTML = `&emsp;65%=${p65} &emsp;70%=${p70} <b>&emsp;75%=${p75}</b> &emsp;80%=${p80}  &emsp;85%=${p85}`;
    
    elem = document.getElementById(`solution${idx}`);
    elem.innerHTML = sol.join(' ').toLowerCase();
}
function callbackSolve(puzzle) {
    //let start = Date.now();  // profiling
    let solve = mk_solver();

    for (let idx = 1; idx <= NumPuzzles; ++idx) {
        console.log("callbackSolve", idx, puzzle[idx]);
        solve.setGame(puzzle[idx].toLowerCase());
	populateDOM(idx, solve.searchGame());
    }
    //let stop = Date.now();	// profiling
    //console.log("callbackSolve 9 ", stop - start);	// profiling
}
function bodyLoaded() {
    //let code = checkCode();
    //if ( undefined === code )
     //   return;
     let code="peace";
    populateCode(code);

    // mk_prng() returns a pseudo random number generator (RNG) function value
    //
    let myrand = mk_prng(code);

    let mygen = boggle(myrand);  // boggle() returns a game-generating function value

    let puzzle = [];
    for (let idx = 1; idx <= NumPuzzles; ++idx) {
        puzzle[idx] = mygen();
	populateGrid(idx, puzzle[idx]);
    }

    // Relenquish back to render engine to update HTML page promptly now that the puzzle
    // grids are populated.  Do this before the more involved computation of
    // decompressing the dictionary and solving the puzzles.
    //
    setTimeout(callbackSolve, 1, puzzle);
}
</script>
</body>
</html>
